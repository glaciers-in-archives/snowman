package integration

import (
	"fmt"
	"net/http"
	"net/http/httptest"
)

// MockSPARQLServer creates a test HTTP server that responds to SPARQL queries
// with canned JSON responses
type MockSPARQLServer struct {
	Server *httptest.Server
	URL    string
}

// NewMockSPARQLServer creates a new mock SPARQL server
func NewMockSPARQLServer() *MockSPARQLServer {
	mux := http.NewServeMux()

	// Handle SPARQL endpoint
	mux.HandleFunc("/sparql", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		// Parse the query from the request
		if err := r.ParseForm(); err != nil {
			http.Error(w, "Bad request", http.StatusBadRequest)
			return
		}

		query := r.FormValue("query")

		// Return different responses based on query content
		var response string
		switch {
		case containsString(query, "index"):
			// Simple SELECT query response for index page
			response = `{
  "head": {
    "vars": ["title", "description"]
  },
  "results": {
    "bindings": [
      {
        "title": {
          "type": "literal",
          "value": "Welcome to Test Site"
        },
        "description": {
          "type": "literal",
          "value": "This is a test site generated by Snowman"
        }
      }
    ]
  }
}`
		case containsString(query, "items"):
			// Multi-page query response
			response = `{
  "head": {
    "vars": ["id", "name", "description"]
  },
  "results": {
    "bindings": [
      {
        "id": {
          "type": "literal",
          "value": "item1"
        },
        "name": {
          "type": "literal",
          "value": "First Item"
        },
        "description": {
          "type": "literal",
          "value": "Description of the first item"
        }
      },
      {
        "id": {
          "type": "literal",
          "value": "item2"
        },
        "name": {
          "type": "literal",
          "value": "Second Item"
        },
        "description": {
          "type": "literal",
          "value": "Description of the second item"
        }
      }
    ]
  }
}`
		default:
			// Default empty response
			response = `{
  "head": {
    "vars": []
  },
  "results": {
    "bindings": []
  }
}`
		}

		w.Header().Set("Content-Type", "application/sparql-results+json")
		fmt.Fprint(w, response)
	})

	server := httptest.NewServer(mux)

	return &MockSPARQLServer{
		Server: server,
		URL:    server.URL + "/sparql",
	}
}

// Close shuts down the mock server
func (m *MockSPARQLServer) Close() {
	m.Server.Close()
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) &&
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
		contains(s, substr)))
}

func contains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
